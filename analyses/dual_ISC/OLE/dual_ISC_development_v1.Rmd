---
title: "dual ISC development v1 - just rolling in the bed"
output: html_document
---

```{r}
library(dplyr)
library(RNifti)

# Immutable parameters
gitdir <- "/data00/layerfMRI/Github_repo/"
bd <- paste0(gitdir,"layerfMRI/analyses/dual_ISC/")

regdatadir <- "/data00/layerfMRI/regdata/"

df <- read.csv("log_summary.csv") %>% 
  arrange(subject,session,task,run) %>% 
  select(-c(Trial,Event.Type,Time,NMov))

df

```


## Load a 4D nifti
```{r}

niifile <- paste0(regdatadir, "/sub_02/ses_01/func/task_1_run_1_4D.nii.gz")

nii <- readNifti(niifile)

dim(nii)

niimean <- apply(nii, MARGIN = c(1,2,3), mean)

image(niimean[5, , ])

```




## Automatically add rows for JU ROI and depth bins
The trick is to create new columns, and then pivot wider.
Maybe it will actually not be necessary, since the columns are automatically created during the analysis, and then they can be pivoted (if necessary)

```{r}

# df <- tibble(sub = letters[1:3])
# 
# df %>% 
#   mutate(BA1 = NA, BA2 = NA) %>% 
#   pivot_longer(cols = c(BA1,BA2), names_to = "JU", values_to = "juval") %>% 
#   mutate(bin1 = NA, bin2 = NA) %>% 
#   pivot_longer(cols = c(bin1,bin2), names_to = "bins", values_to = "binvals") %>%
#   select(-c(juval,binvals)) %>%
#   nest(poppa = c(JU,bins)) %>% 
#   unnest()



# initial df
df <- tibble(sub = 1:10)

# read the table with the names of JU ROI and remove WM regions
julabels <- read.csv("labels_juelich.csv", stringsAsFactors = F) %>% 
  mutate(name = str_replace(name,"['-/]","")) %>%    # get rid of special chars
  mutate(numba = index + 1) %>%
  filter(grepl("GM", name)) %>% 
  select(-index)


# add columns for JU ROI names
df[julabels$name] = NA
df

# pivot JU ROI names to put them in rows (and remove WM)
df <- df %>%
  pivot_longer(cols = contains("GM"), names_to="JU_name") %>% 
  select(-value)

which(julabels$name == "GM_Anterior_intraparietal_sulcus_hIP1_L")

# add columns for depth bins
nbin <- 5
# dfbins <- tibble(bin = as.character(1:nbin))
dfbins <- map_chr(1:nbin, ~ paste0("bin",.x)) %>% as.tibble() %>% rename(nbin = value)

df[dfbins$nbin] = NA


# pivot bins to put them in rows
df <- df %>% 
  pivot_longer(cols = contains("bin"), names_to="bin") %>% 
  select(-value)

```




## Extract for one movie
```{r}

df <- read.csv("log_summary.csv") %>% 
  arrange(subject,session,task,run) %>% 
  select(-c(Trial,Event.Type,Time,NMov,session))

# df <- df %>% 
#   filter(subject == 2, Title == "S1ballonD.avi", run == 1)

df <- df %>% 
  filter(subject == 2, task == 1, run == 1, Type == "M")

df

sub <- "sub_02"
ses = "01"
task = 1
run = 1

fmri <- paste0(regdatadir, "/",sub,"/ses_",ses,"/func/task_",task,"_run_",run,"_4D.nii.gz") %>% readNifti()


# read the files to create the mask to be passed to the 4D fmri matrix
JU_nii <- paste0(bd, "/data_native/", sub, "/atlas/", sub,"_atlas_task_",task,"_run_",run,".nii.gz") %>% readNifti()
D_nii <- paste0(bd, "/data_native/", sub, "/depth/", sub,"_depth_task_",task,"_run_",run,".nii.gz") %>% readNifti()
Z_nii <- paste0(bd, "/data_native/", sub, "/Zstat/", "task_",task,"_run_",run,"/thresh_zstat1.nii.gz") %>% readNifti()

zthr <- 2.3

get_Z_D_JU_vals <- function(zthr, Z_nii, D_nii, JU_nii) {
  
  # Create an index of sig voxels, i.e. whose value is > zthr
  Zthr_idx <- which(Z_nii > zthr)
  
  # Extract Z, D, JU values at the location of Zthr_idx
  Z <- Z_nii[Zthr_idx]
  D <- D_nii[Zthr_idx]
  JU <- JU_nii[Zthr_idx]
 
  # Purrr everything into a list of tibbles and retain only D,Z values 
  # inside JU ROIs
  vals <- tibble(Zthr_idx, Z, D, JU) %>%
    rename(idx = Zthr_idx) %>% 
    filter(JU > 0)

  return(vals)
}


vals <- get_Z_D_JU_vals(zthr, Z_nii, D_nii, JU_nii)

vals


fmri %>% dim()

plot(fmri[10, 100, 100, ], type = 'l' )

df

nbin <- 5
clusterSizeThr <- 50

vals %>% 
  group_by(JU) %>%                    # 1. group_by JU ROI
  mutate(nvox = n()) %>%              # 2. count numba vox in each JU ROI
  arrange(nvox, JU) %>%               # sort by ascending nvox, just to check
  filter(nvox > clusterSizeThr) %>%   # 3. remove JU with nvox < clusterSizeThr
  mutate(D_bins = findInterval(D, seq(0, 1, by=1/nbin))) %>% arrange(D_bins) %>% 
  group_by(JU,D_bins) %>% 
  filter(JU == 33, D_bins == 1)

idx <- c(10,11,12)

df %>% 
  filter(subject == 2, task == 1, run == 1)


```



## Oh madonna! I have to splat the 4D onto a 2D...
```{r}
library(abind)

a <- array(1:9, dim = c(3,3))

# equivalent of repmat
a4d <- do.call("abind", list(rep(list(a), 10), along=3) )

a4d %>% dim()

matrix(a4d,9,10)


a <- array(1:27, dim = c(3,3,3))
# equivalent of repmat
a4d <- do.call("abind", list(rep(list(a), 10), along=4) )
a4d %>% dim()
matrix(a4d, prod(dim(a4d)[1:3]), dim(a4d)[4])


fmri %>% dim()

fmrimat <- matrix(fmri, nrow = prod(dim(fmri)[1:3]), ncol = dim(fmri)[4])

fmrimat %>% dim()

pp <- fmrimat[1e6:(1e6+1000),]

pp %>% dim()

image(t(pp))
plot(pp[1,],type='l')

```




## Let's try to put these puta lists into cells
```{r}

library(tibble)
library(dplyr)
library(purrr)
library(tidyr)
options(digits = 3)

numbarows <- 8

pf <- tibble(
  sub = 1:numbarows, 
  arr = map(1:numbarows, ~ list(NA) )  # this is to create a column which is a list of lists
)


pf <- tibble(
  sub = 1:numbarows, 
  arr = map(1:numbarows, ~ rnorm(3))
)


# unwrap the lists to be able to write.csv (1)
pf %>% 
  group_by(sub) %>% 
  mutate(arroz = paste(arr))

# unwrap the lists to be able to write.csv (2)
pf %>% 
  rowwise() %>% 
  mutate_if(is.list, ~ paste(unlist(.), collapse = ','))

# there might also be a solution with unnest, see:
# https://stackoverflow.com/questions/48024266/save-a-data-frame-with-list-columns-as-csv-file
pf %>% unnest(arr) 


```










































