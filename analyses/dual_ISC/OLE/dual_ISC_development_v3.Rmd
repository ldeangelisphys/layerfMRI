---
title: "dual ISC development v3 - a big love nest"
output: html_document
---


### Select 1 sub/task/run
```{r}
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(RNifti)
library(tictoc)
library(ggplot2)
options(digits = 3)

# Immutable parameters
gitdir <- "/data00/layerfMRI/Github_repo/"
bd <- paste0(gitdir,"layerfMRI/analyses/dual_ISC/")
regdatadir <- "/data00/layerfMRI/regdata/"
depthdatadir <- paste0(bd, "/data_native/")


# load the logs and do some adjustment to names of columns and observations
df <- read.csv("log_summary.csv") %>% 
  arrange(subject,session,task,run) %>% 
  select(-c(Trial,Event.Type,Time,NMov)) %>% 
  mutate(sub = sprintf("sub_%02d",subject) ) %>%
  select(-subject) %>% 
  mutate(ses = sprintf("ses_%02d", session) ) %>% 
  select(-session) %>% 
  mutate(contrast = ifelse(Type == "M", "Motion", "Scrambled") ) %>% 
  mutate(contrast_file = ifelse(Type == "M", "thresh_zstat1.nii.gz", "thresh_zstat2.nii.gz") ) %>% 
  select(-c(Type,total_TR, Duration) ) %>% 
  rename(muvi = Title) %>% 
  relocate(sub, ses, task, run, muvi, start_TR, end_TR, contrast, contrast_file)



# limit to one subject/run/contrast for development
nsub <- "sub_02"
nses <- "ses_01"  # because it's in the filename of the 4D file
ntask <- 1
nrun <- 1
ncontrast <- "thresh_zstat1.nii.gz"

df <- df %>% 
  filter(sub == nsub, ses == nses, task == ntask, run == nrun, contrast == ncontrast)


# # When I will take care of splitting by taskrun, I have two choices: 
# # for each task run, I can either nest or group_by
# pf <- df %>% 
#   filter(sub == "sub_02") %>% 
#   group_by(task, run) %>% 
#   nest()   # 1. nest OR...
#   group_split()  # 2. group_by
# 
# pf$data[[1]]

  
```

### Load images
And get idx as well as the corresponding JU and D.

Note that this is subject/taskrun/contrast specific!
```{r}

fmri4D <- paste0(regdatadir,"/",nsub,"/",nses,"/func/task_",ntask,"_run_",nrun,"_4D.nii.gz") %>% readNifti()
fmri2D <- matrix(fmri4D, nrow = prod(dim(fmri4D)[1:3]), ncol = dim(fmri4D)[4])

JU_nii <- paste0(depthdatadir,"/",nsub,"/atlas/",nsub,"_atlas_task_",ntask,"_run_",nrun,".nii.gz") %>% readNifti()
D_nii  <- paste0(depthdatadir,"/",nsub,"/depth/",nsub,"_depth_task_",ntask,"_run_",nrun,".nii.gz") %>% readNifti()
Z_nii  <- paste0(depthdatadir,"/",nsub, "/Zstat/", "task_",ntask,"_run_",nrun,"/thresh_zstat1.nii.gz") %>% readNifti()


```


### Load images (function)
This is taskrun and contrast specific. I could have done it only taskrun specific, but it would have been too complex to read and process, so I will load the 4D twice, one for Motion, the other for Scrambled. It takes about 30sec instead of 15sec, but it enhances the readability of the code.
```{r}


load_images <- function(df_taskrun_contrast) {
  
  # create a list containing the parameters to load the images
  this <- df_taskrun_contrast[1,] %>% as.list() 
  
  # fmri4D for this taskrun
  fmri4D <- paste0(regdatadir,"/",
                   this$sub,"/", this$ses,"/func/task_",
                   this$task,"_run_", this$run,"_4D.nii.gz") %>% readNifti()
  
  fmri2D <- matrix(fmri4D, nrow = prod(dim(fmri4D)[1:3]), ncol = dim(fmri4D)[4])
  
  
  # Zstat map FOR ONE CONTRAST in the native space of this taskrun
  Z_nii <- paste0(depthdatadir,"/",this$sub, "/Zstat/", 
                  "task_",this$task,
                  "_run_",this$run,
                  "/", this$contrast_file) %>% readNifti()
    
  
  # Depth map in the native space of this taskrun
  D_nii  <- paste0(depthdatadir,"/",
                   this$sub,"/depth/", this$sub,"_depth_task_",
                   this$task,"_run_", this$run,".nii.gz") %>% readNifti()
  
  
  # JUelich regions in the native space of this taskrun
  JU_nii <- paste0(depthdatadir,"/",
                   this$sub,"/atlas/", this$sub,"_atlas_task_",
                   this$task,"_run_", this$run,".nii.gz") %>% readNifti()

  
  nii_list <- list(fmri2D = fmri2D, Z_nii = Z_nii, D_nii = D_nii, JU_nii = JU_nii)

  return(nii_list)

}


# ------------- code for main function -------------

df_taskrun_contrast <- df %>% filter(sub == "sub_02", task == 1, run == 1, contrast == "Motion")
df_taskrun_contrast

nii_list <- load_images(df_taskrun_contrast)

str(nii_list)


```



### Get idx of >zthr voxels, group_by JU and bin
Note that this is subject/taskrun/contrast specific!
```{r}


get_Z_D_JU_vals <- function(zthr, nbin, clusterSizeThr, Z_nii, D_nii, JU_nii) {
  
  # Create an index of sig voxels, i.e. whose value is > zthr
  Zthr_idx <- which(Z_nii > zthr)
  
  # Extract Z, D, JU values at the location of Zthr_idx
  Z <- Z_nii[Zthr_idx]
  D <- D_nii[Zthr_idx]
  JU <- JU_nii[Zthr_idx]
 
  # Purrr everything into a list of tibbles
  # inside JU ROIs
  df_idx <- tibble(Zthr_idx, Z, D, JU) %>%
    rename(idx = Zthr_idx) %>% 
    filter(JU > 0) # to retain only voxels within JU ROIs
  
  # Retain only JU ROI with numba voxels > clusterSizeThr 
  df_idx <- df_idx %>% 
    group_by(JU) %>%                    # 1. group_by JU ROI
    mutate(nvox = n()) %>%              # 2. count numba vox in each JU ROI
    arrange(nvox, JU) %>%               # sort by ascending nvox, just to check
    filter(nvox > clusterSizeThr)       # 3. remove JU with nvox < clusterSizeThr
  
  # Find voxels in each depth bin and write their index in a list in a new column idx_voxels
  df_idx <- df_idx %>%                  
    mutate(D_bins = findInterval(D, seq(0, 1, by=1/nbin))) %>% arrange(JU,D_bins) %>%  # 4. assign voxels to bins
    group_by(JU,D_bins) %>%             # 5. group by JU and bins, to have separate rows in the end
    summarise(                          # 6. create a column where each cell has a list with the idx of sig voxels
      idx_voxels = list(idx),
      .groups = "drop"
    )

  return(df_idx)
}


# ------------- code for main function ------------------

zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
nbin <- 10              # define numba of bins
clusterSizeThr <- 200   # we don't want to consider JU ROIs with only 2 >zthr voxels


df_idx <- get_Z_D_JU_vals(zthr, nbin, clusterSizeThr, nii_list$Z_nii, nii_list$D_nii, nii_list$JU_nii)
df_idx


```



### Test for the main function (see cell below)
Put the whole df_idx shebang for each row of df (contrast specific!)

```{r}

df_taskrun_contrast %>% 
  mutate(shebang = list(df_idx)) %>%  # the function which runs the two functions above goes here!
  unnest(shebang)

```

### Main function for one subject and one taskrun
```{r}

zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
nbin <- 10              # define numba of bins
clusterSizeThr <- 200   # we don't want to consider JU ROIs with only 2 >zthr voxels


# main function
get_idx_voxels_per_bin <- function(df_taskrun_contrast) {
  print(df_taskrun_contrast)
  nii_list <- load_images(df_taskrun_contrast)
  df_idx <- get_Z_D_JU_vals(zthr, nbin, clusterSizeThr,nii_list$Z_nii, nii_list$D_nii, nii_list$JU_nii)
  return(df_idx)
}



# nest by contrast (group_by doesn't work), create idx_voxels per contrast and unnnest
pf <- df %>% filter(sub == "sub_02", task == 1, run == 1) %>% 
  nest_by(contrast) %>% 
  mutate(shebang = list( get_idx_voxels_per_bin(data)) ) %>% 
  unnest(data)

pf %>% unnest(shebang)

pf$shebang[[1]]


```






# really? I need to inject the whole df_idx for each row of df?
fuck yeah!!! :O) finally I got it!
```{r}

# test here
mov <- tibble(muvi = c("muvi_1","muvi_2","muvi_3")) %>% mutate(shebang = list(df_idx))
mov %>% unnest(shebang)

# real deal here
pf <- df %>% 
  mutate(shebang = list(df_idx) ) %>% 
  unnest(shebang)

pf

```



## Prepare df to receive the mean time courses for each bin (OLE, not needed)
We need to get for each muvi one mean time course for each bin of each JU ROI. We could do it by nesting lists, but it would probably be very complex and not easy to read (as well as write to csv).

The easiest way is to use a trick: we prepare for each movie nJU*nbin rows, where nJU is the numba of JU ROIs where there are sig voxels, and nbin is the number of bins. 

The magic is done by creating a new column filled with lists, and then unnesting it. This has to be done (1) for the bins and (2) for the JU ROI **in this order!** since there are nbins for each JU ROI.

Now for the really cool bit: of course there are _not_ sig voxels in all ROIs. Just after we create the extra rows in df, we will retain only those in which there are sig voxels using the info from df_idx!

```{r}

# read the table with the names of JU ROI and remove WM regions
julabels <- read.csv("labels_juelich.csv", stringsAsFactors = F) %>% 
  mutate(name = str_replace(name,"['-/]","")) %>%    # get rid of special chars
  mutate(numba = index + 1) %>%
  filter(grepl("GM", name)) %>% 
  select(-index)


df_BIG <- df %>% 
  mutate(bin = list(1:nbin)) %>% 
  unnest(bin) %>% 
  mutate(JU = list(julabels)) %>%
  unnest(JU) %>% 
  rename(JU_name = name, JU_numba = numba) %>% 
  relocate(bin, JU_numba, muvi)

# create an index of JU ROIs where there are sig voxels, to retain only the necessary
# rows in df_BIG
sig_JU <- df_idx %>% distinct(JU) %>% pull()

df_BIG <- df_BIG %>% 
  filter(JU_numba %in% sig_JU) %>% 
  arrange(JU_numba)

df_BIG

```


## Function to extract the mean TC given fmri2D, idx, start_TR and end_TR
```{r}

get_mean_tc <- function(fmri2D, idx, start_TR, end_TR) {
  
  tcs_at_idx_voxels <- fmri2D[idx, start_TR:end_TR] 
  zscore <- function(x, na.rm = T) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)
  tcs_mean <- apply(tcs_at_idx_voxels, MARGIN = 2, mean) %>% zscore()

}


idx <- df_idx$idx_voxels[[1]]
start_TR <- 0
end_TR <- 100

idx_tcs <- fmri2D[idx, start_TR:end_TR]

get_mean_tc(fmri2D, idx, start_TR = 0, end_TR = 100) %>% plot(type='l')

```



```{r}
df
```

## dunno if it's correct after this point
since I don't recall what was poppa
```{r}
poppa <- df_idx
```


```{r}

idx

df %>%
  filter(contrast == "thresh_zstat1.nii.gz") %>% 
  rowwise() %>% 
  mutate(tc = get_mean_tc(fmri2D, poppa$lidx[[1]], start_TR, end_TR) %>% list() )




```





## Just to see how big this crap is
```{r}

shebang <- tibble(
  taskrun = c("task1_run1","task1_run2",
              "task2_run1","task2_run2",
              "task3_run1","task3_run2",
              "task4_run1","task4_run2")
) %>% 
  mutate(contrast = list(c("thresh_zstat1","thresh_zstat2"))) %>% unnest(contrast) %>% 
  mutate(movie = list(map_chr(1:10, ~ paste("movie_", .x))) ) %>% unnest(movie) %>% 
  mutate(JU = list(map_chr(1:5, ~ paste("BA_", .x)  ))) %>%  unnest(JU) %>% 
  mutate(bin = list(1:10)) %>% unnest(bin)

shebang

library(collapsibleTree)
collapsibleTree(shebang, c("taskrun","contrast","movie","JU","bin"), collapsed = T, zoomable = F)


```








## Garbage collector
```{r}

# Quick plot of all/mean tcs for a given bin
apply(idx_tcs, MARGIN = 2, mean) %>% plot(type='l')

zscore <- function(x, na.rm = T) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)


library(tibble)
idx_tcs %>% t() %>% as.tibble() %>%
  mutate_all(zscore) %>% 
  mutate(time = 1:nrow(.)) %>%
  pivot_longer(cols = starts_with("V"), names_to = "vox", values_to = "intensity") %>%
  arrange(vox) %>% 
  ggplot() +
    geom_line(aes(x = time, y = intensity, color = vox))



```




























