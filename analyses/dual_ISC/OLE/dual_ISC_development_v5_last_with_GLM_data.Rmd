---
title: "dual ISC development v4 - a big love nest(2)"
output: html_document
---


## Load libraries
**NB**: The logfile read here has already been fixed for the issue of the end_TR of some movies being _after_ the numba of volumes in the fmri4D. Please read the `fixing_log_file.html` document in this same folder.

```{r load-libs, message=F}
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(RNifti)
library(tictoc)
library(ggplot2)
library(kableExtra)
options(digits = 3)

# Immutable parameters
gitdir <- "/data00/layerfMRI/Github_repo/"
bd <- paste0(gitdir,"layerfMRI/analyses/dual_ISC/")
regdatadir <- "/data00/layerfMRI/regdata/"
depthdatadir <- paste0(bd, "/data_native/")


# read the table with the names of JU ROI and remove WM regions
julabels <- read.csv("labels_juelich.csv", stringsAsFactors = F) %>% 
  mutate(name = str_replace(name,"['-/]","")) %>%    # get rid of special chars
  mutate(numba = index + 1) %>%
  filter(grepl("GM", name)) %>% 
  select(-index)
```


##  Read the FIXED logfile into df

**NB**: The logfile read here has already been fixed for the issue of the end_TR of some movies being _after_ the numba of volumes in the fmri4D. Please read the `fixing_log_file.html` document in this same folder.

`log_summary_FIXED.csv` has several differences with respect to the original `log_summary.csv`, as the name and values of the column have already been adapted for the pipeline.

```{r load-log-data, message=F}

df <- read.csv("log_summary_FIXED.csv", stringsAsFactors = F)

```



## Getting idx_voxels (1) : Load images

This is subject/taskrun/contrast specific. 
I could have done it only taskrun specific and use some `map` to separately work on the two contrasts, but it would have been too complex to read and process, so I will load the 4D twice, one for Motion, the other for Scrambled. It takes about 30sec instead of 15sec, but it enhances the readability of the code.

```{r}

load_images <- function(df_taskrun_contrast) {
  
  # create a list containing the parameters to load the images
  this <- df_taskrun_contrast[1,] %>% as.list() 
  paste(this$sub, " task ", this$task, " run ", this$run, " ", this$contrast) %>% print()
  
  # fmri4D for this taskrun
  fmri4D <- paste0(regdatadir,"/",
                   this$sub,"/", this$ses,"/func/task_",
                   this$task,"_run_", this$run,"_4D.nii.gz") %>% readNifti()
  
  fmri2D <- matrix(fmri4D, nrow = prod(dim(fmri4D)[1:3]), ncol = dim(fmri4D)[4])
  
  
  # Zstat map FOR ONE CONTRAST in the native space of this taskrun
  Z_nii <- paste0(depthdatadir,"/",this$sub, "/Zstat/", 
                  "task_",this$task,
                  "_run_",this$run,
                  "/", this$contrast_file) %>% readNifti()
    
  
  # Depth map in the native space of this taskrun
  D_nii  <- paste0(depthdatadir,"/",
                   this$sub,"/depth/", this$sub,"_depth_task_",
                   this$task,"_run_", this$run,".nii.gz") %>% readNifti()
  
  
  # JUelich regions in the native space of this taskrun
  JU_nii <- paste0(depthdatadir,"/",
                   this$sub,"/atlas/", this$sub,"_atlas_task_",
                   this$task,"_run_", this$run,".nii.gz") %>% readNifti()

  
  nii_list <- list(fmri2D = fmri2D, Z_nii = Z_nii, D_nii = D_nii, JU_nii = JU_nii)

  return(nii_list)

}


# # ------------- unit test -------------
# df_taskrun_contrast <- df %>% filter(sub == "sub_02", task == 4, run == 1, contrast == "Scrambled")
# df_taskrun_contrast
# 
# nii_list <- load_images(df_taskrun_contrast)
# str(nii_list)


```



## Getting idx_voxels (2) : Get idx of >zthr voxels, grouped by JU and bin
This is subject/taskrun/contrast specific

```{r}

# # Goes with the unit test below: in case you need to see what happens to df_idx
# # in a particular sub/task/run/contrast
# Z_nii <- nii_list$Z_nii
# D_nii <- nii_list$D_nii
# JU_nii <- nii_list$JU_nii


get_idx_voxels <- function(zthr, nbin, clusterSizeThr, Z_nii, D_nii, JU_nii) {
  
  # Create an index of sig voxels, i.e. whose value is > zthr
  Zthr_idx <- which(Z_nii > zthr)
  
  # Extract Z, D, JU values at the location of Zthr_idx
  Z <- Z_nii[Zthr_idx]
  D <- D_nii[Zthr_idx]
  JU <- JU_nii[Zthr_idx]
 
  # Purrr everything into a list of tibbles
  # inside JU ROIs
  df_idx <- tibble(Zthr_idx, Z, D, JU) %>%
    rename(idx = Zthr_idx) %>% 
    filter(JU > 0) # to retain only voxels within JU ROIs
  
  # Retain only JU ROI with numba voxels > clusterSizeThr 
  df_idx <- df_idx %>% 
    group_by(JU) %>%                    # 1. group_by JU ROI
    mutate(nvox = n()) %>%              # 2. count numba vox in each JU ROI
    arrange(nvox, JU) %>%               # sort by ascending nvox, just to check
    filter(nvox > clusterSizeThr)       # 3. remove JU with nvox < clusterSizeThr
  
  # Find voxels in each depth bin and write their index in a list in a new column idx_voxels
  df_idx <- df_idx %>%                  
    mutate(D_bins = findInterval(D, seq(0, 1, by=1/nbin))) %>% arrange(JU,D_bins) %>%  # 4. assign voxels to bins
    group_by(JU,D_bins) %>%             # 5. group by JU and bins, to have separate rows in the end
    summarise(                          # 6. create a column where each cell has a list with the idx of sig voxels
      idx_voxels = list(idx),
      .groups = "drop"
    )

  return(df_idx)
}


# # ------------- unit test ------------------
# zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
# nbin <- 10              # define numba of bins
# clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels
# 
# df_taskrun_contrast <- df %>% filter(sub == "sub_05", task == 4, run == 1, contrast == "Scrambled")
# 
# nii_list <- load_images(df_taskrun_contrast)
# df_idx <- get_idx_voxels(zthr, nbin, clusterSizeThr, nii_list$Z_nii, nii_list$D_nii, nii_list$JU_nii)
# df_idx


```



## Getting idx_voxels (3) : Combine the two functions above

Combine `load_images()` and `get_idx_voxels()` into a fn that can be used within `mutate`

```{r}

# function to load files and extract idx_voxels
get_IDX_per_muvi <- function(df_taskrun_contrast) {
  print(df_taskrun_contrast)
  nii_list <- load_images(df_taskrun_contrast)
  df_idx <- get_idx_voxels(zthr, nbin, clusterSizeThr,nii_list$Z_nii, nii_list$D_nii, nii_list$JU_nii)
  return(df_idx)
}


# # ----------- unit test --------------
# zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
# nbin <- 10              # define numba of bins
# clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels
# 
# test_df <- df %>% filter(sub == "sub_06", task == 1, run == 1) %>%
#   nest_by(contrast) %>% rename(data_contrast = data) %>%         # 1. process the two contrasts separately
#   mutate(shebang = list( get_IDX_per_muvi(data_contrast)) ) %>%  # 2. get the tc for each contrast/JU/bin
#   unnest(data_contrast) %>%                                      # 3. unnest the two contrasts
#   unnest(shebang)                                                # 4. idx_voxels for each (movie/contrast)/JU/bin
# 
# test_df

```





## Function to extract the mean TC given fmri2D, idx, start_TR and end_TR

```{r}

get_mean_tc <- function(fmri2D, idx_voxels, start_TR, end_TR) {

  zscore <- function(x, na.rm = T) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)
      
  idx <- unlist(idx_voxels)
  tcs_at_idx_voxels <- fmri2D[idx, start_TR : (end_TR-1)]
  
  # in case there is only one voxels in that bin, we cannot take the mean
  # but we can still standardize
  if(length(idx) > 1) {
    tcs_mean <- apply(tcs_at_idx_voxels, MARGIN = 2, mean) %>% zscore()    
  } else {
    tcs_mean <- tcs_at_idx_voxels %>% zscore()
  }
  
  return(tcs_mean)
}


# # --------- unit test -------------
# 
# zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
# nbin <- 10              # define numba of bins
# clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels
# 
# 
# df_taskrun <- df %>% filter(sub == "sub_06", task == 1, run == 1)
# 
# nii_list <- load_images(df_taskrun)
# 
# test_df <- df_taskrun %>%
#   nest_by(contrast) %>% rename(data_contrast = data) %>%         # 1. process the two contrasts separately
#   mutate(shebang = list( get_IDX_per_muvi(data_contrast)) ) %>%  # 2. get the tc for each contrast/JU/bin
#   unnest(data_contrast) %>%                                      # 3. unnest the two contrasts
#   unnest(shebang)                                                # 4. idx_voxels for each (movie/contrast)/JU/bin
# 
# # to double check that rowwise is doing its job properly, we can manually calculate the mean tc
# # for one row and compare it with the corresponding row of test_df
# numbarow <- 361
# mini <- test_df[numbarow,]
# 
# nii_list$fmri2D %>% dim()
# 
# mini <- mini %>%
#   mutate(tc_mean = list(get_mean_tc(nii_list$fmri2D, idx_voxels, start_TR, end_TR)) )
# 
# test_df <- test_df %>%
#   rowwise() %>%
#   mutate(tc_mean = list(get_mean_tc(nii_list$fmri2D, idx_voxels, start_TR, end_TR)) )
# 
# par(mfrow=c(1,2))
# mini$tc_mean %>% unlist() %>%  plot(type='l')
# test_df$tc_mean[[numbarow]] %>% unlist() %>% plot(type='l')


```



## Main function for one subject and one taskrun

The smallest function suitable for `map` is processing one taskrun for one subject.

It is not possible to go further (e.g. at the level of the single contrast) since all the bins/JUs/muvis share the same fmri4D taskrun (which is here represented as fmri2D voxels-by-time).

Since the function to calculate the mean tc is `rowwise`, it would in principle require me to store the _whole_ fmri2D in each row, which would take an astronomical amount of time (let alone the fact that the memory would exhaust much before that). 

For this reason I need to use a trick: **a code block between the pipes**, as you can see below between `{curly brackets}`. This will allow me to store the fmri2D in a variable which will then be used by the `get_mean_tc()` function, which operates `rowwise`.

To achieve this, I need to write a small `load_fmri4D` function which loads the fmri4D and converts it to the voxels-by-time `fmri2D` version. This function is called within the block code with `fmri = load_fmri4D(.)`, and returns both the 4D volume (`fmri$fmri2D`) as well as its filename (`fmri$fmri4D_file`) which can be used for controls.

```{r}

# I need a function to load the fmri4D again since I need it in memory for the calculation of the mean_tc
load_fmri4D <- function(df_taskrun) {
  # create a list containing the parameters to load the images
  this <- df_taskrun[1,] %>% as.list() 
  paste(this$sub, " task ", this$task, " run ", this$run) %>% print()
  
  # fmri4D for this taskrun
  fmri4D_file <- paste0(regdatadir,"/",this$sub,"/", this$ses,"/func/task_",this$task,"_run_", this$run,"_4D.nii.gz") 
  fmri4D <- fmri4D_file %>% readNifti()
  
  fmri2D <- matrix(fmri4D, nrow = prod(dim(fmri4D)[1:3]), ncol = dim(fmri4D)[4])
  return(list(fmri2D = fmri2D, fmri4D_file = fmri4D_file))
}


# Main function for one subject and one taskrun
DO_TASKRUN <- function(df_taskrun) {
  
  df_results <- df_taskrun %>%
  nest_by(contrast) %>% rename(data_contrast = data) %>%          # 1. process the two contrasts separately
  mutate(shebang = list( get_IDX_per_muvi(data_contrast)) ) %>%   # 2. get idx for each contrast/JU/bin (same for all muvis)
  unnest(data_contrast) %>%         # 3. unnest the two contrasts
  unnest(shebang) %>%               # 4. idx_voxels for each (movie/contrast)/JU/bin
  {
    fmri = load_fmri4D(.)             # 5. store the fmri2D (and the filename) which is needed for get_mean_tc()
    rowwise(.) %>% 
      mutate(fmri4D_file = fmri$fmri4D_file) %>% 
      mutate(tc_mean = list(get_mean_tc(fmri$fmri2D, idx_voxels, start_TR, end_TR)) )
  } 
  
  return(df_results)
}


# # ------------ unit test ---------------------------
# zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
# nbin <- 10              # define numba of bins
# clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels
# 
# df_taskrun <- df %>% filter(sub == "sub_05", task == 3, run == 2)
# pf <- DO_TASKRUN(df_taskrun)
# 
# pf

```



## Map across taskrun for one sub: just for unit testing
```{r}

# zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
# nbin <- 10              # define numba of bins
# clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels
# 
# tic()
# 
# pf <- df %>% 
#   filter(sub == "sub_05") %>% 
#   group_by(task,run) %>% group_split() %>% 
#   map( ~ .x %>% DO_TASKRUN) %>% 
#   bind_rows()
# 
# toc()
# 
# pf

```


## Map across subjects and taskruns: the real deal 
ETA ~ 30 minutes
```{r}

zthr <- 2.3            # in the ISC results this will likely be a 0/1 logical
nbin <- 10              # define numba of bins
clusterSizeThr <- 10   # we don't want to consider JU ROIs with only 2 >zthr voxels

# df_sub = df %>% filter(sub %in% c("sub_02","sub_03"))

tic()

pf <- df %>%
  group_by(sub,task,run) %>% group_split() %>% 
  map( ~ .x %>% DO_TASKRUN) %>% 
  bind_rows()

toc()

pf

```


## Unfold tc list and write to csv
The solution inspires to [this](https://stackoverflow.com/questions/48024266/save-a-data-frame-with-list-columns-as-csv-file), however some modifications are requires since I think that the one of SO produces the same line for each row (hence wrong).

```{r}

pf %>% 
  ungroup() %>% 
  mutate(tc_mean_unfolded = paste(tc_mean) ) %>% 
  select(-c(idx_voxels, fmri4D_file, tc_mean)) %>% 
  write.csv("binned_JU_time_courses.csv", row.names = F)

```




# Test reading in again
```{r}
df_written <- read.csv("binned_JU_time_courses.csv", stringsAsFactors = F)


df_written %>% 
  arrange(sub, ses, task, run, muvi, JU, D_bins) %>% 
  select(-c(tc_mean_unfolded, contrast_file, dim4, contrast))

df_written %>% 
  select(-c(tc_mean_unfolded, contrast_file, dim4, contrast)) %>% 
  filter(sub == "sub_02", task == 1, run == 1, muvi == "M6cigaretteD.avi") %>% 
  group_by(JU) %>% group_split()

```









## Just to estimate how big this behemot is
```{r}

behemot <- tibble(
  taskrun = c("task1_run1","task1_run2",
              "task2_run1","task2_run2",
              "task3_run1","task3_run2",
              "task4_run1","task4_run2")
) %>% 
  mutate(contrast = list(c("thresh_zstat1","thresh_zstat2"))) %>% unnest(contrast) %>% 
  mutate(movie = list(map_chr(1:5, ~ paste("movie_", .x))) ) %>% unnest(movie) %>% 
  mutate(JU = list(map_chr(1:10, ~ paste("JU_", .x)  ))) %>%  unnest(JU) %>% 
  mutate(bin = list(map_chr(1:10, ~ paste("bin_", .x)  ))) %>%  unnest(bin)  

behemot

library(collapsibleTree)
collapsibleTree(behemot, c("taskrun","contrast","movie","JU","bin"), collapsed = T, zoomable = F)


```








## Garbage collector
```{r}

# Quick plot of all/mean tcs for a given bin
apply(idx_tcs, MARGIN = 2, mean) %>% plot(type='l')

zscore <- function(x, na.rm = T) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)


library(tibble)
idx_tcs %>% t() %>% as.tibble() %>%
  mutate_all(zscore) %>% 
  mutate(time = 1:nrow(.)) %>%
  pivot_longer(cols = starts_with("V"), names_to = "vox", values_to = "intensity") %>%
  arrange(vox) %>% 
  ggplot() +
    geom_line(aes(x = time, y = intensity, color = vox))



```




## Prepare df to receive the mean time courses for each bin (OLE, not needed)
We need to get for each muvi one mean time course for each bin of each JU ROI. We could do it by nesting lists, but it would probably be very complex and not easy to read (as well as write to csv).

The easiest way is to use a trick: we prepare for each movie nJU*nbin rows, where nJU is the numba of JU ROIs where there are sig voxels, and nbin is the number of bins. 

The magic is done by creating a new column filled with lists, and then unnesting it. This has to be done (1) for the bins and (2) for the JU ROI **in this order!** since there are nbins for each JU ROI.

Now for the really cool bit: of course there are _not_ sig voxels in all ROIs. Just after we create the extra rows in df, we will retain only those in which there are sig voxels using the info from df_idx!

```{r}

# read the table with the names of JU ROI and remove WM regions
julabels <- read.csv("labels_juelich.csv", stringsAsFactors = F) %>% 
  mutate(name = str_replace(name,"['-/]","")) %>%    # get rid of special chars
  mutate(numba = index + 1) %>%
  filter(grepl("GM", name)) %>% 
  select(-index)


df_BIG <- df %>% 
  mutate(bin = list(1:nbin)) %>% 
  unnest(bin) %>% 
  mutate(JU = list(julabels)) %>%
  unnest(JU) %>% 
  rename(JU_name = name, JU_numba = numba) %>% 
  relocate(bin, JU_numba, muvi)

# create an index of JU ROIs where there are sig voxels, to retain only the necessary
# rows in df_BIG
sig_JU <- df_idx %>% distinct(JU) %>% pull()

df_BIG <- df_BIG %>% 
  filter(JU_numba %in% sig_JU) %>% 
  arrange(JU_numba)

df_BIG

```



## Issue: the log files indicates movies in time points **after** the end of the fmri4D

**See the `fixing_log_file.Rmd`**

Ritu reports that this is due to the fact that the presentation log kept recording after the stimuli presentation was terminated, into the following sequence, which is a 5 volumes top-up. This does not necessarily happen all the time.

I will fix in the following way: as soon as the df of the log is loaded, I will get the dim4 of the fmri4D (see fn below) as an additional column. I will then check ifelse the end_TR of any video is bigger than dim4, and in this case set it to dim4. 

```{r}

library(fslr)
library(stringr)


df <- read.csv("log_summary.csv") %>% 
  arrange(subject,session,task,run) %>% 
  select(-c(Trial,Event.Type,Time,NMov)) %>% 
  mutate(sub = sprintf("sub_%02d",subject) ) %>%
  select(-subject) %>% 
  mutate(ses = sprintf("ses_%02d", session) ) %>% 
  select(-session) %>% 
  mutate(contrast = ifelse(Type == "M", "Motion", "Scrambled") ) %>% 
  mutate(contrast_file = ifelse(Type == "M", "thresh_zstat1.nii.gz", "thresh_zstat2.nii.gz") ) %>% 
  select(-c(Type) ) %>% 
  rename(muvi = Title) %>% 
  relocate(sub, ses, task, run, muvi, start_TR, end_TR, contrast, contrast_file)


# function to get the dim4 of the fmri4D without loading them - to be passed to the map below
get_fmri4D_dim4 <- function(df_sub_taskrun) {
  this <- df_sub_taskrun[1,] %>% as.list()
  fmri4D_file <- paste0(regdatadir,"/",this$sub,"/", 
                        this$ses,"/func/task_",this$task,"_run_", this$run,"_4D.nii.gz")
  dim4_info_raw <- fslr::fslhd(fmri4D_file, verbose = F)[9]
  dim4_info <- str_split(dim4_info_raw,"\t")[[1]] %>% tail(1) %>% as.numeric()
  df_sub_taskrun %>% mutate(dim4 = dim4_info)
}

# get the dim4
pf <- df %>% 
  group_by(sub,task,run) %>% 
  group_split() %>% 
  map(~ .x %>% get_fmri4D_dim4) %>% 
  bind_rows()


# you can see the problem here, because the dim4 is higher than the end_TR in some movies
pf %>% 
  mutate(dim4 = as.numeric(dim4)) %>% 
  filter(end_TR > dim4) %>% 
  # filter(sub != "sub_08") %>% 
  mutate(diff_end_dim4 = dim4 - end_TR) %>% 
  select(-c(contrast,contrast_file))


# fixing the issue
pf %>% 
  mutate(end_TR_new = ifelse(end_TR > dim4, dim4, end_TR) ) %>%  # here's the fix 
  relocate(end_TR_new, .after=end_TR) %>% 
  filter(end_TR > dim4) %>% 
  select(-c(contrast, contrast_file,Duration))


```




















